# Historia #915240: BUG - Organizar los Campos Errados del Detalle de Cobro

**Estado:** Refinado (SM) - Lista para Estimación  
**Fecha Creación:** Octubre 29, 2025  
**Fecha Refinamiento:** Octubre 29, 2025  
**Origen:** Historia importada y validada  
**Tipo:** Bug Fix  
**Prioridad:** Alta  

---

## Historia de Usuario

**YO COMO:** Expedidor  
**QUIERO:** Que se organicen los campos errados del detalle de cobro  
**PARA:** Poder descargarlo y tener la información que necesita el cliente  

---

## Objetivo de Negocio

A hoy cuando descargamos el detalle de cobro en producción se identificaron 9 ajustes críticos que deben realizarse para poder contar con el informe completamente funcional y entregar información precisa a los clientes corporativos.

Estos ajustes impactan la generación del reporte en el flujo de **MicroIntegradorReportesVidaGrupo**, específicamente en:
- **WorkQueue 2**: Lógica de construcción de registros (código Java)
- **Consultas SQL**: Queries a BillingCenter y PolicyCenter

---

## Contexto Técnico

**Componente afectado:** MicroIntegradorReportesVidaGrupo  
**Flujo:** Generación de Reporte de Detalle de Cobro  
**Documentación:** `docs/architecture/flujo-generacion-reporte-detalle-cobro.md`  

**Puntos de cambio:**
- WorkQueue 2 Processors (construcción de registros con ~50 campos)
- Consultas SQL a esquemas BC (BillingCenter) y PC (PolicyCenter)
- Tabla de persistencia: `CHARGE_DETAIL_ITEMS` (esquema ADM_VIDAGRUPOREPORTES)
- Formato de salida: Archivo CSV enviado a Azure Massive Download API

---

## Criterios de Aceptación

### ✅ Criterio 1: Visualizar el campo "Número Póliza Colectiva" correctamente

**ESTADO:** ✅ Ya resuelto (número incorrecto corregido)

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** en el campo "Número Póliza Colectiva" se visualice el número de la póliza master  

---

### Criterio 2: Visualizar el campo "Identificación del Afiliado" correctamente

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** en el campo "Identificación del Afiliado" se visualice concatenado el tipo y número de documento del asegurado que tenga parentesco afiliado  

**Reglas de Negocio:**
- **Formato de concatenación:** `{tipo_doc}{numero_doc}` (sin separador)
  - Ejemplo: `CC12345678` (tipo: CC, número: 12345678)
  - Ejemplo: `TI98765432` (tipo: TI, número: 98765432)
- **Unicidad:** Solo puede haber un afiliado por asegurado en la póliza
- **Fuente de datos:** Asegurado con parentesco tipo "Afiliado" en PolicyCenter

**Ejemplos:**
- Si tipo_doc = "CC" y numero_doc = "1234567890" → Mostrar: `CC1234567890`
- Si tipo_doc = "TI" y numero_doc = "987654321" → Mostrar: `TI987654321`

---

### Criterio 3: Visualizar el campo "Valor Total Prima x Asegurado" correctamente

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** en el campo "Valor Total Prima x Asegurado" se visualice el valor que suma los campos "Valor Prima x Asegurado" + "Valor Impuesto"  

**Reglas de Negocio:**
- **Fórmula:** `Valor Total Prima x Asegurado = Valor Prima x Asegurado + Valor Impuesto`
- **Formato numérico:** Mantener 2 decimales
- **Validación:** El resultado debe ser >= 0

**Ejemplo:**
- Valor Prima x Asegurado: $50,000.00
- Valor Impuesto: $9,500.00
- **Valor Total Prima x Asegurado: $59,500.00**

---

### Criterio 4: Visualizar el campo "Valor Total Afiliado" correctamente

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** en el campo "Valor Total Afiliado" se visualice en la celda que corresponde al afiliado el valor que suma los campos "Valor Total Prima x Asegurado" de los asegurados tipo grupo familiar de este mismo  

**Reglas de Negocio:**
- **Aplicable solo para:** Registros de asegurados con parentesco "Afiliado"
- **Fórmula:** Sumar todos los "Valor Total Prima x Asegurado" del grupo familiar (afiliado + dependientes)
- **Para dependientes:** Este campo debe estar vacío o en 0
- **Formato numérico:** Mantener 2 decimales

**Ejemplo:**
- Afiliado (CC12345678): Valor Total Prima = $100,000
- Cónyuge: Valor Total Prima = $80,000
- Hijo 1: Valor Total Prima = $50,000
- Hijo 2: Valor Total Prima = $50,000
- **Valor Total Afiliado (mostrado en fila del afiliado): $280,000.00**

---

### ✅ Criterio 5: Visualizar el campo "Parentesco" correctamente

**ESTADO:** ✅ Ya resuelto

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** en el campo "Parentesco" se visualice la sigla del parentesco de cada asegurado y no el código  

---

### ✅ Criterio 6: Visualizar el campo "Tipo de Operación" correctamente

**ESTADO:** ✅ Ya resuelto

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** en el campo "Tipo de Operación" se visualice el tipo de operación que se visualiza en transacciones de póliza en PC (cotización, cambio de póliza, etc)  

---

### ✅ Criterio 7: Visualizar las columnas de valor asegurado de todas las coberturas contratadas

**ESTADO:** ✅ Ya resuelto

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** se visualicen las columnas de valor asegurado por cada cobertura contratada para cada asegurado  

---

### ✅ Criterio 8: Visualizar el campo "Prima Vida" correctamente

**ESTADO:** ✅ Ya resuelto

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** en el campo "Prima Vida" se visualice el valor de la prima de la cobertura de vida  

---

### Criterio 9: Visualizar los nombres de los campos que tienen caracteres especiales correctamente

**DADO** que se expidió una póliza de vida grupo y se generó la factura  
**CUANDO** se ingrese a billing y se descargue el detalle de cobro  
**ENTONCES** en los campos con tildes y caracteres especiales se visualicen correctamente y no con el signo de interrogación "?"  

**Campos afectados:**
- Número Póliza Colectiva (antes: N?mero P?liza Colectiva)
- Número de Riesgo (antes: N?mero de riesgo)
- Número de Contrato (antes: N?mero de contrato)
- Descripción de Riesgo (antes: Descripci?n de Riesgo)
- Solución (antes: Soluci?n)
- Identificación del Afiliado (antes: Identificaci?n del Afiliado)
- Identificación del Asegurado (antes: Identificaci?n del Asegurado)
- Número de Factura (antes: N?mero de factura)
- Fecha Generación Factura (antes: Fecha generaci?n factura)
- Tipo de Operación (antes: Tipo de operaci?n)

**Reglas de Negocio:**
- **Encoding del archivo CSV:** UTF-8 sin BOM
- **Validación:** Todos los caracteres especiales (á, é, í, ó, ú, ñ, Ñ) deben visualizarse correctamente
- **Aplicar a:** Headers del CSV y contenido de las celdas

---

## Datos de Prueba

**Factura de prueba:** `100011784911`  
**Ambiente:** Desarrollo/QA  
**Uso:** Validar todos los criterios de aceptación antes de desplegar a producción  

**Validaciones esperadas:**
1. ✅ Número Póliza Colectiva muestra la póliza master
2. Identificación del Afiliado en formato `{tipo_doc}{numero_doc}`
3. Valor Total Prima x Asegurado = Prima + Impuesto
4. Valor Total Afiliado suma correctamente el grupo familiar
5. ✅ Parentesco muestra siglas
6. ✅ Tipo de Operación muestra descripción
7. ✅ Todas las coberturas tienen columnas de valor asegurado
8. ✅ Prima Vida muestra valor correcto
9. Todos los headers y datos con tildes se ven correctamente

---

## Contexto Técnico (SM)

### Base del Refinamiento

**Análisis arquitectónico utilizado:** ✅ SÍ - Basado en análisis previo validado del arquitecto

**Decisiones arquitectónicas adoptadas:**
- Patrón Hexagonal Architecture (Ports & Adapters) con Dependency Injection
- Distribución de responsabilidades entre WorkQueue 1 (consultas SQL) y WorkQueue 2 (cálculos de negocio)
- Refactorización de inyección de dependencias vía constructor en ambos WorkQueues
- Creación de `FamilyCalculatorService` como servicio de dominio

**Componentes validados por el arquitecto:**
- WorkQueue1Processors (consultas SQL a BC/PC)
- WorkQueue2Processors (transformación y cálculos)
- FamilyCalculatorService (nuevo - cálculo de grupo familiar)
- CoverageProvider (sin cambios - coberturas ya incluidas)

**Patrones seguidos:**
- SQL-First Approach para concatenación de identificación del afiliado
- Service Layer Pattern para cálculo de valor total afiliado
- Repository Pattern para acceso a datos

### Validación Técnica con Desarrollador

**Fecha de validación:** Octubre 29, 2025

**Aclaraciones críticas incorporadas:**

1. **Cobertura "Invalidez por Accidente con Armas" (Criterio pendiente - investigación requerida):**
   - ✅ Confirmado: Campo existe en CSV pero llega con valor = 0
   - ✅ Problema puede estar en: query SQL O transformación WorkQueue 2
   - ✅ Factura de prueba confirmada: `100011784911` (debe tener valor > 0)
   - 🔍 Requiere: Query de diagnóstico SQL + validación en transformaciones

2. **Valor Total Afiliado (Criterio 4 - PRIORIDAD ALTA):**
   - ✅ Implementar en **WorkQueue 2** (no en WorkQueue 1)
   - ✅ Usar datos base de `CHARGE_DETAIL_ITEMS`
   - ✅ Requiere consulta adicional en WorkQueue 2 para obtener grupo familiar
   - ✅ Sumar valores de todos los asegurados del mismo grupo familiar

3. **Encoding UTF-8 (Criterio 9):**
   - ✅ **YA RESUELTO** - Caracteres especiales funcionan correctamente
   - ✅ No requiere implementación adicional

4. **Prioridad de implementación:**
   - 🥇 **CRÍTICO**: Criterio 4 - Valor Total Afiliado (suma grupo familiar)
   - 🥈 **ALTO**: Cobertura "Invalidez por Accidente con Armas" (investigación + corrección)
   - 🥉 **MEDIO**: Criterio 2 - Identificación del Afiliado (concatenación tipo + número)

### Análisis de Arquitectura y Documentación

**Arquitectura:**

- **Componentes principales afectados:**
  - `MicroIntegradorReportesVidaGrupo` - Microservicio principal (Apache Camel 3.20)
  - `WorkQueue1Processors` - Consultas SQL a BillingCenter/PolicyCenter
  - `WorkQueue2Processors` - Transformación y cálculos de negocio
  - `FamilyCalculatorService` (NUEVO) - Servicio de dominio para cálculo de grupo familiar

- **Módulos relevantes:**
  - `application/processor/workqueue/` - Procesadores de work queues
  - `domain/service/` - Servicios de dominio (nuevo servicio aquí)
  - `domain/ports/query/` - Ports para consultas adicionales
  - `infrastructure/adapter/repository/query/` - Implementación de queries

- **Patrones arquitectónicos:**
  - Hexagonal Architecture (separación dominio/infraestructura)
  - Work Queue Pattern con Quartz Scheduler
  - Repository Pattern para acceso a datos
  - Service Layer Pattern para lógica de negocio

**Componentes Específicos según Análisis Arquitectónico:**

- **WorkQueue1Processors:** Modificación Media
  - Actualizar `script_policy.sql` para incluir `tipo_documento`
  - Implementar concatenación `tipo_documento || numero_documento` en INSERT-SELECT
  - Investigar query de cobertura "Invalidez por Accidente con Armas"
  - Aplicar refactorización de inyección de dependencias vía constructor

- **WorkQueue2Processors:** Modificación Media-Alta
  - Inyectar nuevo `FamilyCalculatorService` vía constructor
  - Implementar consulta adicional para obtener grupo familiar desde `CHARGE_DETAIL_ITEMS`
  - Calcular "Valor Total Afiliado" para asegurados con parentesco "Afiliado"
  - Validar que cobertura "Invalidez por Accidente con Armas" no se pierda
  - Aplicar refactorización de inyección de dependencias

- **FamilyCalculatorService (NUEVO):** Servicio de dominio
  - Responsabilidad: Calcular suma de "Valor Total Prima x Asegurado" del grupo familiar
  - Métodos: `calculateFamilyTotal()`, `groupByAffiliate()`
  - Ubicación: `domain/service/FamilyCalculatorService.java`
  - Inyección: Recibir repositorio vía constructor para consulta de grupo familiar

- **CoverageProvider:** Sin cambios
  - Coberturas ya incluidas correctamente
  - Solo requiere validación de que no se pierda valor en transformaciones

**Flujos de Negocio Relacionados:**

- **Flujo principal:** `flujo-generacion-reporte-detalle-cobro.md`
  - WorkQueue 1: Consulta de datos de Guidewire (BC/PC)
  - WorkQueue 2: Construcción de registros con ~50 campos
  - WorkQueue 3: Envío a Azure Massive Download API
  - WorkQueue 4: Limpieza de registros antiguos

**Extensiones de flujo necesarias:**
- WorkQueue 2: Agregar paso de consulta adicional para grupo familiar antes de construcción de registros

### Análisis de Impacto

**Código existente a modificar:**

- `src/main/java/com/sura/mi/reportes/vidagrupo/application/processor/workqueue/WorkQueue1Processors.java`
- `src/main/java/com/sura/mi/reportes/vidagrupo/application/processor/workqueue/WorkQueue2Processors.java`
- `src/main/resources/sql/script_policy.sql` - Consultas a PolicyCenter
- `src/main/resources/sql/script_bc_pc.sql` - Consultas combinadas (si aplica)

**Archivos nuevos a crear:**

- `src/main/java/com/sura/mi/reportes/vidagrupo/domain/service/FamilyCalculatorService.java` (interface)
- `src/main/java/com/sura/mi/reportes/vidagrupo/domain/service/impl/FamilyCalculatorServiceImpl.java` (implementación)
- `src/main/java/com/sura/mi/reportes/vidagrupo/domain/ports/query/ChargeDetailQueryPort.java` (nuevo port para consulta de grupo familiar)
- `src/main/java/com/sura/mi/reportes/vidagrupo/infrastructure/adapter/repository/query/ChargeDetailQueryRepository.java` (implementación del port)

**Breaking changes:** Ninguno - Solo correcciones de datos y nuevos cálculos

**Migraciones:** No requiere cambios de esquema en BD

**Configuración:** No requiere nuevas variables de entorno

### Análisis de Código Base

**Consultas SQL Existentes (script_policy.sql):**

Basado en la documentación del flujo, las consultas actuales obtienen:
- Datos de asegurados desde `pc_grouppersonnel`
- Coberturas desde `pc_coverage` y `pc_grouppersonnel_coverage`
- Valores asegurados y primas por cobertura

**Modificaciones SQL requeridas:**

```sql
-- CAMBIO 1: Agregar tipo_documento para concatenación (Criterio 2)
SELECT 
    pc.document_type,              -- NUEVO CAMPO
    pc.document_number,
    pc.document_type || pc.document_number as affiliate_document, -- Concatenación
    pc.relationship,
    pc.affiliate_id,
    -- ... resto de campos existentes
FROM pc_grouppersonnel pc
WHERE pc.invoice_number = :invoiceNumber
```

**Investigación SQL requerida (Cobertura "Invalidez por Accidente con Armas"):**

```sql
-- Query de diagnóstico para identificar nombre exacto de cobertura
SELECT DISTINCT 
    cov.coverage_code,
    cov.coverage_name,
    cov.coverage_type,
    cov.insured_value
FROM pc_coverage cov
WHERE UPPER(cov.coverage_name) LIKE '%INVALIDEZ%'
  AND UPPER(cov.coverage_name) LIKE '%ARMAS%'
  OR UPPER(cov.coverage_name) LIKE '%ACCIDENTE%ARMAS%'
ORDER BY cov.coverage_name;

-- Query de validación con factura de prueba
SELECT 
    gp.document_number,
    gp.relationship,
    cov.coverage_code,
    cov.coverage_name,
    COALESCE(cov.insured_value, 0) as insured_value,
    COALESCE(gpc.premium, 0) as premium
FROM pc_grouppersonnel gp
LEFT JOIN pc_grouppersonnel_coverage gpc ON gp.id = gpc.insured_id
LEFT JOIN pc_coverage cov ON gpc.coverage_id = cov.id
WHERE gp.invoice_number = '100011784911'
  AND (UPPER(cov.coverage_name) LIKE '%INVALIDEZ%ARMAS%'
       OR cov.coverage_code = 'INA' -- Código hipotético, validar
       OR cov.coverage_code LIKE 'INV%ACC%')
ORDER BY gp.document_number, cov.coverage_name;
```

**Lógica de WorkQueue2 (Construcción de Registros):**

Basado en el flujo documentado, WorkQueue2 actualmente:
1. Lee datos consolidados desde `CHARGE_DETAIL_PRINCIPAL` (columna `data_json`)
2. Parsea JSON con datos de BC/PC
3. Aplica reglas de negocio usando `CoverageProvider`
4. Construye registros de detalle con ~50 campos
5. Inserta batch en `CHARGE_DETAIL_ITEMS`

**Modificaciones requeridas en WorkQueue2:**

```java
// Pseudocódigo de lógica nueva
for (InsuredData insured : allInsureds) {
    // ... lógica existente de construcción de registro ...
    
    // NUEVO: Calcular Valor Total Afiliado (Criterio 4)
    if ("Afiliado".equals(insured.getRelationship())) {
        // Consultar grupo familiar desde CHARGE_DETAIL_ITEMS
        List<ChargeDetailItem> familyGroup = 
            chargeDetailQueryPort.findByAffiliateId(
                invoiceNumber, 
                insured.getAffiliateId()
            );
        
        // Calcular suma usando servicio de dominio
        BigDecimal familyTotal = 
            familyCalculatorService.calculateFamilyTotal(familyGroup);
        
        detailRecord.setValorTotalAfiliado(familyTotal);
    } else {
        detailRecord.setValorTotalAfiliado(null); // Dependientes vacío
    }
    
    // VALIDACIÓN: Cobertura "Invalidez por Accidente con Armas"
    // Verificar que no se sobrescribe a cero
    for (CoverageData coverage : insured.getCoverages()) {
        if (coverage.isInvalidezPorAccidenteConArmas()) {
            logger.debug("Cobertura IPAA - Valor: {}", coverage.getInsuredValue());
            // Asegurar que se mantiene el valor del SQL
        }
    }
}
```

**Estrategias de Testing:**

Basado en el stack tecnológico documentado (JUnit 4.13.2, Mockito 4.11.0):
- Tests unitarios para `FamilyCalculatorService` con mocks de repositorio
- Tests de integración para consultas SQL con base de datos H2/Oracle de desarrollo
- Tests de regresión con factura `100011784911` para validar todos los criterios
- Mutation testing con PIT 1.15.8 (configurado en el proyecto)

---

## Tareas de Implementación (SM)

### Fase 1: Preparación y Análisis de Código Existente

**Objetivo:** Comprender implementación actual y validar datos con queries de diagnóstico

- [ ] **Análisis de código existente de WorkQueues**
  - [ ] Revisar `WorkQueue1Processors.java` - identificar estructura actual y puntos de modificación
  - [ ] Revisar `WorkQueue2Processors.java` - identificar lógica de construcción de registros
  - [ ] Documentar patrón actual de inyección de dependencias (para refactorizar)
  - [ ] Identificar ubicación de `CoverageProvider` y su uso actual

- [ ] **Ejecutar queries de diagnóstico SQL** (AC: Investigación Cobertura)
  - [ ] Conectar a base de datos de desarrollo PolicyCenter
  - [ ] Ejecutar query 1: Identificar nombre exacto de cobertura "Invalidez por Accidente con Armas"
  - [ ] Ejecutar query 2: Validar datos de factura `100011784911` - verificar valor > 0 esperado
  - [ ] Ejecutar query 3: Validar que campo `tipo_documento` existe en `pc_grouppersonnel`
  - [ ] Documentar hallazgos: nombre exacto de cobertura, estructura de JOINs, valores esperados

- [ ] **Análisis de scripts SQL existentes**
  - [ ] Revisar `script_policy.sql` - identificar consulta de asegurados actual
  - [ ] Revisar `script_bc_pc.sql` - identificar consulta de coberturas actual
  - [ ] Identificar si query usa INNER JOIN o LEFT JOIN para coberturas
  - [ ] Validar manejo de NULLs con COALESCE en valores asegurados

### Fase 2: Implementación de Servicio de Dominio (Valor Total Afiliado - PRIORIDAD ALTA)

**Objetivo:** Crear servicio para calcular suma de grupo familiar

- [ ] **Crear FamilyCalculatorService** (AC: 4)
  - [ ] Crear interface `domain/service/FamilyCalculatorService.java`
    - Método: `BigDecimal calculateFamilyTotal(List<ChargeDetailItem> familyGroup)`
    - Método: `Map<String, List<ChargeDetailItem>> groupByAffiliate(List<ChargeDetailItem> allItems)`
  - [ ] Crear implementación `domain/service/impl/FamilyCalculatorServiceImpl.java`
    - Implementar lógica de suma de "Valor Total Prima x Asegurado"
    - Validar que suma sea >= 0
    - Mantener 2 decimales en resultado
    - Logging de cálculos para debugging

- [ ] **Crear Port para consulta de grupo familiar** (AC: 4)
  - [ ] Crear `domain/ports/query/ChargeDetailQueryPort.java`
    - Método: `List<ChargeDetailItem> findByAffiliateId(String invoiceNumber, String affiliateId)`
  - [ ] Crear implementación `infrastructure/adapter/repository/query/ChargeDetailQueryRepository.java`
    - Implementar query SQL a `CHARGE_DETAIL_ITEMS`
    - Filtrar por `invoice_number` y `affiliate_id`
    - Ordenar por `relationship` (Afiliado primero, luego dependientes)

- [ ] **Tests unitarios de FamilyCalculatorService** (AC: 4)
  - [ ] Test: Calcular suma correcta con 1 afiliado + 3 dependientes
  - [ ] Test: Manejar grupo familiar con solo afiliado (sin dependientes)
  - [ ] Test: Validar formato de 2 decimales
  - [ ] Test: Validar que suma nunca es negativa
  - [ ] Mock de `ChargeDetailQueryPort` con Mockito

### Fase 3: Modificación de WorkQueue 1 (Consultas SQL)

**Objetivo:** Incluir tipo de documento para concatenación y corregir cobertura

- [ ] **Modificar script_policy.sql - Agregar tipo_documento** (AC: 2)
  - [ ] Añadir campo `document_type` en SELECT principal
  - [ ] Implementar concatenación: `document_type || document_number AS affiliate_document`
  - [ ] Validar que campo existe en esquema `pc_grouppersonnel`
  - [ ] Probar query en BD de desarrollo con factura `100011784911`

- [ ] **Investigar y corregir query de cobertura "Invalidez por Accidente con Armas"**
  - [ ] Usar nombre exacto identificado en Fase 1 (query de diagnóstico)
  - [ ] Verificar que JOIN es LEFT JOIN (no INNER) para no filtrar registros
  - [ ] Añadir COALESCE para manejar NULLs: `COALESCE(cov.insured_value, 0)`
  - [ ] Validar con query de diagnóstico que retorna valor > 0 para factura de prueba
  - [ ] Documentar cambio en comentario SQL

- [ ] **Refactorizar WorkQueue1Processors - Inyección de Dependencias** (AC: Refactorización)
  - [ ] Identificar dependencias instanciadas con `new ...()` 
  - [ ] Convertir a inyección vía constructor
  - [ ] Actualizar configuración de Spring/Camel para autowiring
  - [ ] Actualizar tests unitarios con mocks de nuevas dependencias

### Fase 4: Modificación de WorkQueue 2 (Cálculos de Negocio - PRIORIDAD ALTA)

**Objetivo:** Implementar cálculo de Valor Total Afiliado y validar cobertura

- [ ] **Inyectar FamilyCalculatorService en WorkQueue2Processors** (AC: 4)
  - [ ] Añadir `FamilyCalculatorService` como dependencia del constructor
  - [ ] Añadir `ChargeDetailQueryPort` como dependencia del constructor
  - [ ] Actualizar configuración de inyección de dependencias
  - [ ] Actualizar tests con mocks de nuevos servicios

- [ ] **Implementar cálculo de Valor Total Afiliado** (AC: 4)
  - [ ] Identificar punto en código donde se construye registro de detalle
  - [ ] Añadir condicional: `if ("Afiliado".equals(insured.getRelationship()))`
  - [ ] Consultar grupo familiar: `chargeDetailQueryPort.findByAffiliateId(...)`
  - [ ] Calcular suma: `familyCalculatorService.calculateFamilyTotal(familyGroup)`
  - [ ] Asignar resultado a campo `valorTotalAfiliado` del registro
  - [ ] Para dependientes: asignar `null` o `0` en campo `valorTotalAfiliado`

- [ ] **Validar que cobertura "Invalidez por Accidente con Armas" no se pierde**
  - [ ] Añadir logging debug antes/después de transformaciones de coberturas
  - [ ] Verificar que valor del SQL se mantiene en construcción del registro
  - [ ] Validar que no se sobrescribe a cero en lógica de negocio
  - [ ] Añadir assertion en tests para validar valor > 0 en factura de prueba

- [ ] **Refactorizar WorkQueue2Processors - Inyección de Dependencias** (AC: Refactorización)
  - [ ] Convertir todas las dependencias a inyección vía constructor
  - [ ] Actualizar configuración de Spring/Camel
  - [ ] Actualizar tests unitarios con mocks

### Fase 5: Testing Integral y Validación

**Objetivo:** Validar todos los criterios con factura de prueba

- [ ] **Tests unitarios completos**
  - [ ] WorkQueue1Processors: Mock de queries SQL, validar datos retornados
  - [ ] WorkQueue2Processors: Mock de servicios, validar cálculos
  - [ ] FamilyCalculatorService: Tests de lógica de suma (ya creados en Fase 2)
  - [ ] ChargeDetailQueryRepository: Tests de integración con H2/Oracle

- [ ] **Tests de integración con factura 100011784911** (AC: 1, 2, 3, 4, 5, 6, 7, 8, 9)
  - [ ] ✅ AC1: Validar "Número Póliza Colectiva" (ya resuelto - regresión)
  - [ ] AC2: Validar "Identificación del Afiliado" formato `{tipo}{numero}`
  - [ ] AC3: Validar "Valor Total Prima x Asegurado" = Prima + Impuesto
  - [ ] **AC4: Validar "Valor Total Afiliado" suma de grupo familiar** (CRÍTICO)
  - [ ] ✅ AC5: Validar "Parentesco" siglas (ya resuelto - regresión)
  - [ ] ✅ AC6: Validar "Tipo de Operación" descripción (ya resuelto - regresión)
  - [ ] ✅ AC7: Validar columnas de valor asegurado coberturas (ya resuelto - regresión)
  - [ ] ✅ AC8: Validar "Prima Vida" valor correcto (ya resuelto - regresión)
  - [ ] ✅ AC9: Validar caracteres especiales UTF-8 (ya resuelto - regresión)
  - [ ] **VALIDACIÓN CRÍTICA:** "Invalidez por Accidente con Armas" tiene valor > 0

- [ ] **Tests de regresión** (AC: Todos)
  - [ ] Ejecutar generación de reporte con al menos 3 facturas diferentes
  - [ ] Validar que campos existentes no se afectaron negativamente
  - [ ] Validar que otros tipos de coberturas siguen funcionando
  - [ ] Validar performance: tiempo de ejecución similar a versión anterior

- [ ] **Mutation Testing con PIT**
  - [ ] Ejecutar PIT en clases modificadas y nuevas
  - [ ] Validar cobertura de mutantes > 80%
  - [ ] Corregir tests que no detectan mutaciones

### Fase 6: Code Review y Documentación

**Objetivo:** Asegurar calidad y actualizar documentación

- [ ] **Code Review**
  - [ ] Revisión de implementación de FamilyCalculatorService
  - [ ] Revisión de modificaciones en WorkQueue1Processors
  - [ ] Revisión de modificaciones en WorkQueue2Processors
  - [ ] Revisión de queries SQL modificadas
  - [ ] Validar principios SOLID y Clean Code
  - [ ] Validar que refactorización de DI está correcta

- [ ] **Actualizar documentación arquitectónica** (Recomendación para Arquitecto)
  - [ ] Sugerir actualizar `flujo-generacion-reporte-detalle-cobro.md` con:
    - WorkQueue 2: Agregar paso de consulta de grupo familiar
    - Diagrama de secuencia: Incluir llamada a FamilyCalculatorService
  - [ ] Sugerir actualizar `architecture-microintegrador-reportes-vidagrupo.md` con:
    - Nuevo servicio de dominio: FamilyCalculatorService
    - Refactorización de inyección de dependencias aplicada
    - Lecciones aprendidas de esta corrección

- [ ] **Documentación técnica interna**
  - [ ] Actualizar comentarios Javadoc en clases modificadas
  - [ ] Documentar queries SQL con comentarios explicativos
  - [ ] Actualizar README.md del microservicio si es necesario

### Fase 7: Despliegue y Monitoreo

**Objetivo:** Desplegar a ambientes y validar en producción

- [ ] **Despliegue a ambiente de Desarrollo**
  - [ ] Build exitoso con Gradle
  - [ ] Validación de imagen Docker
  - [ ] Despliegue en ambiente de desarrollo
  - [ ] Smoke tests: generación de reporte con factura 100011784911

- [ ] **Validación en QA**
  - [ ] Despliegue a ambiente QA
  - [ ] Ejecución de suite completa de tests de aceptación
  - [ ] Validación funcional con usuario de negocio / QA
  - [ ] Aprobación de QA para producción

- [ ] **Despliegue a Producción**
  - [ ] Plan de rollback documentado
  - [ ] Despliegue en ventana de mantenimiento
  - [ ] Monitoreo de logs en Splunk post-despliegue
  - [ ] Validación con facturas reales en producción
  - [ ] Confirmación de usuario de negocio

- [ ] **Monitoreo Post-Despliegue**
  - [ ] Monitorear logs de errores (primeras 24 horas)
  - [ ] Validar performance de WorkQueues
  - [ ] Revisar métricas de tiempo de generación de reportes
  - [ ] Confirmar que no hay regresiones en otros campos

---

**Notas sobre vinculación con Criterios de Aceptación:**

- **AC: 4** - Todas las tareas de FamilyCalculatorService y cálculo de Valor Total Afiliado
- **AC: 2** - Modificación de SQL para tipo_documento y concatenación
- **AC: 3** - Ya implementado, solo validación en tests
- **AC: Investigación Cobertura** - Queries de diagnóstico y corrección de cobertura "Invalidez por Accidente con Armas"
- **AC: 1, 5, 6, 7, 8, 9** - Ya resueltos, solo tests de regresión

---



- [ ] Los 9 criterios de aceptación están implementados y probados
- [ ] Se validaron cambios en WorkQueue 2 (lógica Java de construcción)
- [ ] Se validaron cambios en consultas SQL a BC y PC
- [ ] Archivo CSV se genera con encoding UTF-8 sin BOM
- [ ] Pruebas exitosas con factura 100011784911 en ambiente de desarrollo
- [ ] Pruebas de regresión: otras facturas siguen funcionando correctamente
- [ ] Code review completado y aprobado
- [ ] Documentación técnica actualizada si hubo cambios significativos
- [ ] Despliegue a QA y validación funcional con usuario de negocio
- [ ] Despliegue a producción y monitoreo post-despliegue

---

## Definición de Hecho (DoD)

**✅ Criterios implementados y validados:**

- [ ] **Criterio 4 (PRIORIDAD CRÍTICA):** Valor Total Afiliado calculado correctamente sumando grupo familiar
- [ ] **Criterio 2 (PRIORIDAD ALTA):** Identificación del Afiliado en formato `{tipo_doc}{numero_doc}`
- [ ] **Cobertura "Invalidez por Accidente con Armas" (PRIORIDAD ALTA):** Valor > 0 en factura de prueba
- [ ] **Criterio 3:** Valor Total Prima x Asegurado = Prima + Impuesto (validación de regresión)
- [ ] ✅ Criterio 1: Número Póliza Colectiva (ya resuelto - test de regresión)
- [ ] ✅ Criterio 5: Parentesco en siglas (ya resuelto - test de regresión)
- [ ] ✅ Criterio 6: Tipo de Operación (ya resuelto - test de regresión)
- [ ] ✅ Criterio 7: Columnas de valor asegurado coberturas (ya resuelto - test de regresión)
- [ ] ✅ Criterio 8: Prima Vida (ya resuelto - test de regresión)
- [ ] ✅ Criterio 9: Caracteres especiales UTF-8 (ya resuelto - NO requiere implementación)

**✅ Componentes nuevos creados:**

- [ ] FamilyCalculatorService (interface + implementación)
- [ ] ChargeDetailQueryPort (interface)
- [ ] ChargeDetailQueryRepository (implementación)

**✅ Componentes modificados:**

- [ ] WorkQueue1Processors - Refactorización DI + SQL modificado
- [ ] WorkQueue2Processors - Refactorización DI + cálculo de Valor Total Afiliado
- [ ] script_policy.sql - Agregar tipo_documento + corrección cobertura
- [ ] script_bc_pc.sql (si aplica) - Consultas combinadas

**✅ Validaciones técnicas:**

- [ ] Queries de diagnóstico SQL ejecutadas exitosamente
- [ ] Nombre exacto de cobertura "Invalidez por Accidente con Armas" identificado
- [ ] Factura 100011784911 validada con todos los criterios
- [ ] Tests unitarios: cobertura > 80%
- [ ] Mutation testing (PIT): cobertura de mutantes > 80%
- [ ] Tests de regresión: otras facturas funcionan correctamente
- [ ] Code review completado y aprobado

**✅ Documentación:**

- [ ] Comentarios Javadoc actualizados en clases modificadas
- [ ] Queries SQL documentadas con comentarios explicativos
- [ ] Sugerencias de actualización para arquitecto:
  - Actualizar `flujo-generacion-reporte-detalle-cobro.md`
  - Actualizar `architecture-microintegrador-reportes-vidagrupo.md`
  - Documentar lecciones aprendidas

**✅ Despliegue:**

- [ ] Despliegue a ambiente de desarrollo exitoso
- [ ] Validación en QA con usuario de negocio
- [ ] Despliegue a producción completado
- [ ] Monitoreo post-despliegue (primeras 24 horas)

---

## Impacto en el Sistema

**Componentes afectados:**
- ✅ MicroIntegradorReportesVidaGrupo (WorkQueue 2)
- ✅ Consultas SQL a BillingCenter y PolicyCenter
- ✅ Tabla CHARGE_DETAIL_ITEMS
- ✅ Generación de archivo CSV

**Riesgos:**
- **Bajo:** Los cambios son principalmente correcciones de datos y formato
- **Mitigación:** Validar con factura de prueba antes de producción
- **Rollback:** Posible mediante revert de código si se detectan problemas

**Dependencias:**
- No requiere cambios en Azure Massive Download API
- No requiere cambios en RabbitMQ
- No requiere cambios en estructura de BD (solo lógica)

---

## Información de Importación

**Proceso completado:** ✅ Validación de completitud  
**Análisis realizado:** ✅ Consistencia con documentación arquitectónica  
**Preguntas de aclaración:** ✅ 9 preguntas respondidas e integradas  
**Versión final confirmada:** ✅ Usuario confirmó  

**Archivo creado:** `915240.BUG-organizar-campos-errados-detalle-cobro.story.md`

**Documentación relacionada:**
- Flujo técnico: `docs/architecture/flujo-generacion-reporte-detalle-cobro.md`
- Arquitectura: `docs/architecture/architecture-microintegrador-reportes-vidagrupo.md`

**Mejoras aplicadas:**
- ✅ Reglas de negocio específicas para cada criterio
- ✅ Ejemplos concretos de formato y cálculos
- ✅ Datos de prueba documentados
- ✅ Contexto técnico completo
- ✅ Definición de hecho detallada

---

## Análisis Arquitectónico (Arquitecto)

### Decisiones de Diseño

**Patrón Arquitectónico:** Hexagonal Architecture (Ports & Adapters) con Dependency Injection

**Estrategia de Implementación:**

La corrección de los 3 campos pendientes se implementará aprovechando la oportunidad para refactorizar el uso incorrecto de inyección de dependencias detectado en el proyecto:

**Distribución de Responsabilidades por WorkQueue:**

- **WorkQueue 1 (Consulta de Datos)**: Responsable de obtención de datos vía SQL
  - Modificar consultas SQL a PolicyCenter para incluir `tipo_documento`
  - Concatenar tipo + número de documento para campo "Identificación del Afiliado"
  - Investigar y corregir query de cobertura "Invalidez por Accidente con Armas" (valor en cero)
  
- **WorkQueue 2 (Construcción de Registros)**: Responsable de transformación y cálculos de negocio
  - Implementar cálculo de "Valor Total Afiliado" (suma del grupo familiar)
  - Validar que valor de cobertura "Invalidez por Accidente con Armas" no se pierda en transformaciones

**Componentes Principales:**

- **WorkQueue1Processors:** Modificación Media
  - Actualizar consultas SQL para incluir tipo de documento del afiliado
  - Implementar concatenación `tipo_documento || numero_documento` en INSERT-SELECT
  - Investigar query de cobertura "Invalidez por Accidente con Armas" (campo existe pero valor = 0)
  - **Refactorización:** Aplicar inyección de dependencias correcta vía constructor

- **WorkQueue2Processors:** Modificación Media
  - Implementar cálculo de "Valor Total Afiliado" (suma de grupo familiar)
  - Validar que cobertura "Invalidez por Accidente con Armas" mantenga su valor
  - **Refactorización:** Aplicar inyección de dependencias correcta vía constructor

- **FamilyCalculatorService (Nuevo):** Servicio de dominio
  - Responsabilidad: Calcular suma de "Valor Total Prima x Asegurado" del grupo familiar
  - Métodos: `calculateFamilyTotal()`, `groupByAffiliate()`
  - Ubicación: `domain/service/FamilyCalculatorService.java`

### Especificaciones Técnicas

**Interfaces Requeridas:**

```java
// FamilyCalculatorService.java (NUEVO)
public interface FamilyCalculatorService {
    BigDecimal calculateFamilyTotal(List<InsuredData> familyGroup);
    Map<String, List<InsuredData>> groupByAffiliate(List<InsuredData> allInsureds);
}
```

**Consultas SQL Modificadas (script_policy.sql):**

```sql
-- CAMBIO 1: Agregar tipo_documento para concatenación
SELECT 
    pc.document_type,        -- NUEVO
    pc.document_number,
    pc.document_type || pc.document_number as affiliate_document, -- Concatenación
    pc.relationship,
    pc.affiliate_id,
    ...
FROM pc_grouppersonnel pc
WHERE ...
```

**Puntos de Investigación Críticos:**

1. **Cobertura "Invalidez por Accidente con Armas":**
   - El campo YA EXISTE en el CSV pero llega en valor = 0
   - Investigar query SQL: nombre exacto de cobertura, JOINs, manejo de NULLs
   - Validar que no se sobrescribe a cero en lógica de WorkQueue1 o WorkQueue2

**Modelos de Datos:**

```java
public class InsuredData {
    private String documentType;      // NUEVO: Agregado desde SQL
    private String affiliateDocument; // NUEVO: Concatenación tipo+número
    private String affiliateId;       // Para agrupar familia
    private BigDecimal familyTotal;   // NUEVO: Valor Total Afiliado
    private List<CoverageData> coverages; // Incluye "Invalidez por Accidente con Armas"
    // ... otros campos existentes
}
```

**Lógica de Cálculo - Valor Total Afiliado:**

```java
// WorkQueue2Processors (pseudocódigo)
if (insured.getRelationship().equals("Afiliado")) {
    List<InsuredData> familyGroup = getFamilyGroup(insured.getAffiliateId());
    BigDecimal familyTotal = familyCalculatorService.calculateFamilyTotal(familyGroup);
    detailRecord.setValorTotalAfiliado(familyTotal);
} else {
    detailRecord.setValorTotalAfiliado(null); // Dependientes vacío
}
```

### Impacto Arquitectónico

**Componentes Modificados:**

- ✅ **WorkQueue1Processors** - Modificación Media (SQL + refactorización DI)
- ✅ **WorkQueue2Processors** - Modificación Media (cálculo familia + refactorización DI)
- ✅ **Consultas SQL PolicyCenter** - Modificación Mayor (tipo doc + investigar cobertura)

**Componentes Nuevos:**

- ✅ **FamilyCalculatorService** - Servicio de dominio para cálculo de suma familiar

**Componentes Sin Cambios:**

- CoverageProvider - NO requiere modificación (cobertura ya incluida)
- Tabla CHARGE_DETAIL_ITEMS - NO requiere cambios estructurales
- Azure Massive Download API - NO requiere cambios
- RabbitMQ - NO requiere cambios

**Documentación a Actualizar:**

- `flujo-generacion-reporte-detalle-cobro.md` - Actualizar sección WorkQueue 1 y 2 con nuevos campos
- `architecture-microintegrador-reportes-vidagrupo.md` - Documentar refactorización de inyección de dependencias
- Scripts SQL de referencia en `src/main/resources/sql/`

**Riesgos Arquitectónicos:**

| Riesgo                                          | Probabilidad | Impacto | Mitigación                                                       |
| ----------------------------------------------- | ------------ | ------- | ---------------------------------------------------------------- |
| Query SQL no retorna tipo de documento          | Baja         | Alto    | Validar con query de diagnóstico en BD de desarrollo             |
| Cobertura con nombre diferente en PC            | Alta         | Alto    | **CRÍTICO**: Query de diagnóstico para identificar nombre exacto |
| JOIN incorrecto filtrando cobertura             | Media        | Alto    | Revisar plan de ejecución SQL, cambiar a LEFT JOIN si necesario  |
| Valor asegurado es realmente cero en datos      | Media        | Medio   | Validar con DBA/negocio si es dato real o error de configuración |
| Regresión en otros campos del CSV               | Baja         | Alto    | Tests de regresión con factura 100011784911                      |
| Inyección de dependencias rompe tests existentes| Media        | Medio   | Actualizar tests unitarios con mocks de nuevos servicios         |

### Validación Arquitectónica

**Validado por:** Usuario (Esteban Colorado)  
**Fecha de validación:** Octubre 29, 2025  
**Feedback incorporado:** 

1. ✅ Tipo de identificación del afiliado resolver en WorkQueue 1 vía SQL (no en WorkQueue 2)
2. ✅ Valor Asegurado Invalidez por Accidente con Armas - campo existe, investigar por qué llega en cero
3. ✅ Cobertura ya incluida - no modificar CoverageProvider, solo validar query SQL

**Enfoque aprobado:** Exploratorio con ajustes específicos del usuario

### Fases de Implementación

**Fase 1: Crear FamilyCalculatorService**
- Implementar servicio de dominio para cálculo de suma familiar
- Ubicación: `domain/service/FamilyCalculatorService.java`
- Interface con métodos: `calculateFamilyTotal()`, `groupByAffiliate()`

**Fase 2: Modificar Consultas SQL en WorkQueue 1**
- Agregar campo `tipo_documento` en query de PolicyCenter
- Implementar concatenación `tipo_documento || numero_documento` para "Identificación del Afiliado"
- **INVESTIGAR**: Query de cobertura "Invalidez por Accidente con Armas" - por qué valor = 0
  - Verificar nombre exacto de cobertura en PC
  - Revisar JOINs (LEFT vs INNER)
  - Validar manejo de NULLs (usar COALESCE)
  - Confirmar filtros WHERE no excluyen cobertura

**Fase 3: Refactorizar WorkQueue1Processors**
- Aplicar inyección de dependencias correcta vía constructor
- Eliminar instanciaciones directas (`new ...()`)
- Actualizar lógica de consolidación de datos para incluir tipo de documento

**Fase 4: Modificar WorkQueue2Processors**
- Inyectar `FamilyCalculatorService` vía constructor
- Implementar cálculo de "Valor Total Afiliado" para asegurados con parentesco "Afiliado"
- Validar que valor de cobertura "Invalidez por Accidente con Armas" no se pierda en transformaciones
- Aplicar inyección de dependencias correcta en todas las dependencias

**Fase 5: Validación y Testing**
- Query de diagnóstico SQL para validar tipo de documento
- Query de diagnóstico para identificar nombre exacto de cobertura "Invalidez por Accidente con Armas"
- Testing con factura de prueba `100011784911`
- Validar encoding UTF-8 sin BOM (Criterio 9)
- Tests de regresión en otros campos del CSV

### Referencias Arquitectónicas

**Documentación consultada:**
- `docs/architecture/index.md` - GPS Arquitectónico del ecosistema
- `docs/architecture/flujo-generacion-reporte-detalle-cobro.md` - Flujo completo WorkQueues
- `docs/architecture/architecture-microintegrador-reportes-vidagrupo.md` - Arquitectura hexagonal

**Patrones aplicados:**
- Hexagonal Architecture (Ports & Adapters) - Patrón base del proyecto
- Dependency Injection - Refactorización crítica aplicada a WorkQueues
- Service Layer Pattern - FamilyCalculatorService
- SQL-First Approach - Resolver en consultas cuando sea más eficiente (tipo documento)
- Repository Pattern - Acceso a datos (ya existente)

**Queries de Diagnóstico SQL:**

```sql
-- Diagnóstico 1: Validar tipo de documento
SELECT 
    document_type,
    document_number,
    document_type || document_number as concatenated,
    relationship
FROM pc_grouppersonnel
WHERE relationship = 'Afiliado'
AND invoice_number = '100011784911'
LIMIT 10;

-- Diagnóstico 2: Identificar nombre exacto de cobertura
SELECT DISTINCT 
    coverage_code,
    coverage_name,
    coverage_type
FROM pc_coverage
WHERE UPPER(coverage_name) LIKE '%INVALIDEZ%'
  AND UPPER(coverage_name) LIKE '%ARMAS%'
ORDER BY coverage_name;

-- Diagnóstico 3: Verificar por qué valor asegurado = 0
SELECT 
    gp.document_number,
    cov.coverage_code,
    cov.coverage_name,
    cov.insured_value,
    cov.premium
FROM pc_grouppersonnel gp
LEFT JOIN pc_grouppersonnel_coverage gpc ON gp.id = gpc.insured_id
LEFT JOIN pc_coverage cov ON gpc.coverage_id = cov.id
WHERE gp.invoice_number = '100011784911'
  AND UPPER(cov.coverage_name) LIKE '%INVALIDEZ%ARMAS%';
```

---

## Estimación

**Fecha de Estimación:** Octubre 29, 2025  
**Estimador:** SM - Ceiba  
**Metodología:** Análisis basado en arquitectura hexagonal, refactorización completa y debugging en tiempo real  

### Análisis de Complejidad

**Nivel de complejidad:** **ALTA**

**Justificación basada en análisis del código base:**

1. **🔴 Refactorización Completa del Proyecto (40%)**: NO solo WorkQueue1 y WorkQueue2
   - Clase base utilitaria de BD convertida a servicio inyectable
   - **Impacto**: Refactorización de TODOS los flujos del microservicio que usan la clase utilitaria
   - Incluye: WorkQueue1, WorkQueue2, WorkQueue3, WorkQueue4, GenerateDetailChargeProcessor, GetDetailChargeProcessor
   - Actualización masiva de configuración de Camel/Spring para inyección de dependencias
   - Actualización masiva de tests unitarios (mocks de BD en todos los procesadores)

2. **🔴 Incertidumbre de Análisis de Datos (25%)**:
   - **Valor Total Afiliado**: Tabla origen desconocida - requiere análisis de esquema de BD + validación con negocio
   - **Tipo de Identificación**: Validar si campo existe en PolicyCenter o requiere consulta adicional
   - **Valor Asegurado en Cero**: Requiere **debugging en tiempo real** en ambiente de desarrollo/QA
   - Puede requerir: análisis de plan de ejecución SQL, trazas de log, validación de datos con DBA

3. **🟡 Debugging en Tiempo Real (20%)**:
   - Despliegue en ambiente de desarrollo con logging debug activado
   - Ejecutar flujo completo con factura de prueba 100011784911
   - Analizar logs de WorkQueue1 (consulta SQL) + WorkQueue2 (transformaciones)
   - Identificar punto exacto donde valor asegurado se convierte en cero
   - Puede requerir: breakpoints remotos, análisis de JSON intermedio, validación de transformaciones

**Refactorización requerida:** **SÍ - COMPLETA DEL PROYECTO**

**Precedentes encontrados:**
- ⚠️ NO hay precedente de refactorización total de clase utilitaria a servicio inyectable
- ⚠️ NO hay precedente de debugging en tiempo real para análisis de transformaciones
- ⚠️ Incertidumbre sobre tablas de origen de datos (requiere investigación exploratoria)

### Estimación por Tareas

| Fase | Descripción | Sr Con IA | Método Ceiba |
|------|-------------|-----------|--------------|
| Fase 1 | Análisis Exploratorio (BD + DBA + tablas origen) | 3.5 h | 2.1 h |
| Fase 2 | Refactorización Clase Base BD | 3.0 h | 1.8 h |
| Fase 3 | Refactorizar TODOS los Procesadores | 6.0 h | 3.6 h |
| Fase 4 | Actualizar TODOS los Tests | 4.5 h | 2.7 h |
| Fase 5 | FamilyCalculatorService | 3.0 h | 1.8 h |
| Fase 6 | Modificar WorkQueue1 SQL | 3.0 h | 1.8 h |
| Fase 7 | Debugging Tiempo Real | 3.5 h | 2.1 h |
| Fase 8 | Modificar WorkQueue2 | 4.0 h | 2.4 h |
| Fase 9 | Testing Integral Completo | 5.5 h | 3.3 h |
| Fase 10 | Code Review Completo | 2.5 h | 1.5 h |
| Fase 11 | Despliegue y Validación | 3.0 h | 1.8 h |
| **TOTAL** | | **41.5 h** | **24.9 h** |

### Totales por Perfil

| Perfil | Total Sin IA | Total Con IA | Método Ceiba |
|--------|--------------|--------------|--------------|
| Jr | 110.0 h | 82.5 h | - |
| Semi Sr | 78.0 h | 58.5 h | - |
| Sr | 55.0 h | 41.5 h | - |
| Método Ceiba | - | - | 24.9 h |

### Puntos de Historia

**Usando escala Fibonacci (1 punto = ~7 horas de trabajo):**

**Estimación Recomendada:**
- **Sr Con IA**: **6 puntos** (~41.5h, ~1 semana completa)
- **Método Ceiba**: **4 puntos** (~24.9h, ~3-4 días)

**Con incertidumbre máxima:**
- **Sr Con IA**: **8-10 puntos** (~56-70h, ~1.5-2 semanas)
- **Método Ceiba**: **5-6 puntos** (~35-42h, ~5-6 días)

### Análisis de Riesgo

**Porcentaje de desviación estimado:** **±35%**

**Factores de riesgo identificados:**

1. **🔴 CRÍTICO - Incertidumbre de Tablas Origen de Datos**
   - Tabla para "Valor Total Afiliado" desconocida
   - Campo "Tipo de Identificación" puede no existir en PolicyCenter
   - Requiere: análisis de esquema BD + validación con DBA + validación con negocio
   - **Impacto potencial**: +8-16 horas si requiere consultas adicionales o lógica compleja

2. **🔴 CRÍTICO - Debugging Tiempo Real Requerido**
   - Valor asegurado en cero requiere análisis en runtime
   - Puede requerir: múltiples iteraciones de deploy + logging + análisis de trazas
   - Posibles causas: JOIN incorrecto, transformación que sobrescribe, NULL handling, dato real
   - **Impacto potencial**: +6-12 horas si la causa es compleja o requiere múltiples iteraciones

3. **🔴 CRÍTICO - Refactorización Completa del Proyecto**
   - Clase utilitaria de BD usada en TODOS los flujos
   - Requiere refactorización de: WorkQueue1-4, procesadores REST, configuración completa
   - Riesgo de introducir regresiones en flujos no relacionados con el bug
   - **Impacto potencial**: +10-15 horas si hay problemas con configuración Spring/Camel

**Recomendaciones para mitigar riesgos:**
- **📋 Fase 1 Crítica**: Priorizar análisis exploratorio de tablas ANTES de iniciar desarrollo
- **🔍 Debugging Temprano**: Configurar ambiente de desarrollo con logging debug desde el inicio
- **📞 Coordinación DBA**: Agendar sesión con DBA en Fase 1 para validar esquema
- **🧪 Tests Incrementales**: Refactorizar un procesador a la vez + tests antes de continuar

### Recomendación Estratégica

Considerar **split de historia** en 2 partes:
- **Historia 915240-A**: Refactorización de clase base BD + inyección de dependencias (3-4 puntos)
- **Historia 915240-B**: Corrección de campos (Valor Total Afiliado + Tipo ID + Valor Asegurado) (3-4 puntos)

**Beneficios del split:**
- ✅ Reducir riesgo técnico mediante validación incremental
- ✅ Validar refactorización antes de implementar correcciones
- ✅ Permitir rollback independiente si hay problemas
- ✅ Facilitar code review y testing de cada componente por separado
- ✅ Mejorar visibilidad de progreso en el sprint

### Validación de Estimación

**✅ Criterios de validación cumplidos:**
- Análisis arquitectónico completo de MicroIntegradorReportesVidaGrupo
- Revisión de documentación de flujo de generación de reporte
- Identificación de precedentes y patrones existentes
- Cuantificación de incertidumbre y riesgos
- Consideración de refactorización completa del proyecto
- Inclusión de debugging en tiempo real

**Estimación aprobada por:** Esteban Colorado  
**Fecha de aprobación:** Octubre 29, 2025
